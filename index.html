<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>App váº½ 36</title>

<style>
body{
    margin:0;
    font-family:Arial;
    background:#f2f2f2;
    text-align:center;
    transition:0.3s;
}

.dark{
    background:#1e1e1e;
    color:white;
}

.tools{
    padding:10px;
    background:white;
    position:sticky;
    top:0;
    z-index:10;
    transition:0.3s;
}

.dark .tools{
    background:#2b2b2b;
}

button{
    padding:5px 10px;
    margin:4px;
}

.canvas-wrapper{
    position:relative;
    display:flex;
    justify-content:center;
}

canvas{
    border:2px solid black;
    background:white;
    touch-action:none;
    width:95%;
    max-width:1000px;
}

#preview{
    position:absolute;
    border:2px dashed red;
    pointer-events:none;
    display:none;
}
</style>
</head>

<body>

<h2>ðŸŽ¨ Paint MAX</h2>

<div class="tools">
Color <input type="color" id="color" value="#000000">
Brush <input type="range" id="size" min="1" max="40" value="5">
Eraser <input type="range" id="eraserSize" min="10" max="100" value="40">

<button onclick="setTool('brush')">Brush</button>
<button onclick="setTool('eraser')">Eraser</button>
<button onclick="setTool('rect')">Rect</button>
<button onclick="setTool('circle')">Circle</button>
<button onclick="setTool('line')">Line</button>

<button onclick="undo()">Undo</button>
<button onclick="redo()">Redo</button>
<button onclick="save()">Save</button>
<button onclick="toggleGrid()">Grid</button>
<button onclick="toggleDark()">Dark</button>
<button onclick="clearCanvas()">Clear</button>
</div>

<div class="canvas-wrapper">
<canvas id="canvas"></canvas>
<div id="preview"></div>
</div>

<script>
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
const preview=document.getElementById("preview");

let tool="brush";
let painting=false;
let startX,startY;
let history=[],redoStack=[];
let grid=false;

// Resize
function resize(){
let ratio=window.devicePixelRatio||1;
let w=canvas.clientWidth;
let h=window.innerHeight*0.6;
canvas.width=w*ratio;
canvas.height=h*ratio;
canvas.style.height=h+"px";
ctx.setTransform(ratio,0,0,ratio,0,0);
redraw();
}
window.addEventListener("resize",resize);
resize();

// Save state
function saveState(){
history.push(canvas.toDataURL());
if(history.length>30)history.shift();
redoStack=[];
}

// Undo
function undo(){
if(history.length>0){
redoStack.push(canvas.toDataURL());
let img=new Image();
img.src=history.pop();
img.onload=()=>{ctx.clearRect(0,0,canvas.width,canvas.height);ctx.drawImage(img,0,0);}
}
}

// Redo
function redo(){
if(redoStack.length>0){
let img=new Image();
img.src=redoStack.pop();
img.onload=()=>{ctx.clearRect(0,0,canvas.width,canvas.height);ctx.drawImage(img,0,0);}
}
}

// Position
function pos(e){
let r=canvas.getBoundingClientRect();
let x=(e.touches?e.touches[0].clientX:e.clientX)-r.left;
let y=(e.touches?e.touches[0].clientY:e.clientY)-r.top;
return{x,y};
}

// Start
function start(e){
e.preventDefault();
painting=true;
let p=pos(e);
startX=p.x;
startY=p.y;
saveState();

if(tool==="brush"){
ctx.beginPath();
ctx.moveTo(p.x,p.y);
}
if(tool==="eraser")erase(p);
}

// End
function end(){
painting=false;
ctx.beginPath();
}

// Move
function move(e){
e.preventDefault();
let p=pos(e);

if(tool==="brush"){
if(!painting)return;
ctx.lineWidth=document.getElementById("size").value;
ctx.lineCap="round";
ctx.strokeStyle=document.getElementById("color").value;
ctx.lineTo(p.x,p.y);
ctx.stroke();
}

if(tool==="eraser"){
showPreview(p);
if(painting)erase(p);
}

if(["rect","circle","line"].includes(tool)){
if(!painting)return;
redraw();
ctx.strokeStyle=document.getElementById("color").value;
ctx.lineWidth=2;

if(tool==="rect"){
ctx.strokeRect(startX,startY,p.x-startX,p.y-startY);
}

if(tool==="circle"){
ctx.beginPath();
ctx.arc(startX,startY,Math.hypot(p.x-startX,p.y-startY),0,Math.PI*2);
ctx.stroke();
}

if(tool==="line"){
ctx.beginPath();
ctx.moveTo(startX,startY);
ctx.lineTo(p.x,p.y);
ctx.stroke();
}
}
}

// Erase
function erase(p){
let s=document.getElementById("eraserSize").value;
ctx.clearRect(p.x-s/2,p.y-s/2,s,s);
}

// Preview
function showPreview(p){
let s=document.getElementById("eraserSize").value;
preview.style.display="block";
preview.style.width=s+"px";
preview.style.height=s+"px";
preview.style.left=(canvas.offsetLeft+p.x-s/2)+"px";
preview.style.top=(canvas.offsetTop+p.y-s/2)+"px";
}

// Tool
function setTool(t){
tool=t;
if(t!=="eraser")preview.style.display="none";
}

// Save PNG
function save(){
let link=document.createElement("a");
link.download="paint.png";
link.href=canvas.toDataURL();
link.click();
}

// Grid
function toggleGrid(){
grid=!grid;
redraw();
}

// Dark mode
function toggleDark(){
document.body.classList.toggle("dark");
}

// Clear
function clearCanvas(){
saveState();
ctx.clearRect(0,0,canvas.width,canvas.height);
}

// Redraw
function redraw(){
let img=new Image();
img.src=history.length?history[history.length-1]:"";
img.onload=()=>{
ctx.clearRect(0,0,canvas.width,canvas.height);
if(img.src)ctx.drawImage(img,0,0);
if(grid)drawGrid();
};
if(!history.length&&grid)drawGrid();
}

// Grid draw
function drawGrid(){
let size=20;
ctx.strokeStyle="#ddd";
for(let x=0;x<canvas.width;x+=size)
ctx.strokeRect(x,0,1,canvas.height);
for(let y=0;y<canvas.height;y+=size)
ctx.strokeRect(0,y,canvas.width,1);
}

// PC
canvas.addEventListener("mousedown",start);
canvas.addEventListener("mouseup",end);
canvas.addEventListener("mousemove",move);

// Mobile
canvas.addEventListener("touchstart",start);
canvas.addEventListener("touchend",end);
canvas.addEventListener("touchmove",move);

// Hold E for eraser
document.addEventListener("keydown",e=>{
if(e.key==="e")setTool("eraser");
});
document.addEventListener("keyup",e=>{
if(e.key==="e")setTool("brush");
});
</script>

</body>
</html>